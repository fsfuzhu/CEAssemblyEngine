// CEScriptParser.cpp - CE脚本解析器实现
#include "Core/CEAssemblyEngine.h"
#include "CEScriptParser.h"
#include "Utils/DebugHelper.h"
#include <sstream>
#include <algorithm>
#include <regex>

CEScriptParser::CEScriptParser() {}
CEScriptParser::~CEScriptParser() {}

bool CEScriptParser::ParseScript(const std::string& content) {
    Clear();

    std::istringstream stream(content);
    std::string line;
    bool inEnableBlock = false;
    bool inDisableBlock = false;

    while (std::getline(stream, line)) {
        // 处理行：去除空白和注释
        line = ProcessLine(line);
        if (line.empty()) continue;

        // 检查块标记
        if (line == "[ENABLE]") {
            inEnableBlock = true;
            inDisableBlock = false;
            continue;
        }
        else if (line == "[DISABLE]") {
            inEnableBlock = false;
            inDisableBlock = true;
            continue;
        }

        // 添加到相应的块
        if (inEnableBlock) {
            m_enableBlock.push_back(line);
        }
        else if (inDisableBlock) {
            m_disableBlock.push_back(line);
        }
    }

    return !m_enableBlock.empty();
}

ParsedCommand CEScriptParser::ParseLine(const std::string& line) {
    ParsedCommand cmd;
    cmd.rawLine = line;
    cmd.type = GetCommandType(line);

    // 提取参数
    std::istringstream iss(line);
    std::string token;
    bool firstToken = true;

    while (iss >> token) {
        if (firstToken) {
            firstToken = false;
            // 第一个token是命令本身（除了汇编指令）
            if (cmd.type != CommandType::ASSEMBLY) {
                continue;
            }
        }

        // 处理括号
        if (token.find('(') != std::string::npos) {
            size_t start = token.find('(');
            size_t end = line.find(')', start);
            if (end != std::string::npos) {
                std::string params = line.substr(start + 1, end - start - 1);
                std::istringstream paramStream(params);
                std::string param;
                while (std::getline(paramStream, param, ',')) {
                    // 去除空白
                    param.erase(0, param.find_first_not_of(" \t"));
                    param.erase(param.find_last_not_of(" \t") + 1);
                    if (!param.empty()) {
                        cmd.parameters.push_back(param);
                    }
                }
                break;
            }
        }
        else {
            cmd.parameters.push_back(token);
        }
    }

    return cmd;
}

void CEScriptParser::Clear() {
    m_enableBlock.clear();
    m_disableBlock.clear();
}

std::string CEScriptParser::ProcessLine(const std::string& line) {
    // 去除注释
    size_t commentPos = line.find("//");
    std::string processed = (commentPos != std::string::npos) ? line.substr(0, commentPos) : line;

    // 去除前后空白
    processed.erase(0, processed.find_first_not_of(" \t\r\n"));
    processed.erase(processed.find_last_not_of(" \t\r\n") + 1);

    return processed;
}

CommandType CEScriptParser::GetCommandType(const std::string& line) {
    if (line.empty()) return CommandType::UNKNOWN;

    // 标签定义（以冒号结尾）
    if (line.back() == ':') {
        return CommandType::ASSEMBLY;  // 标签是特殊的汇编指令
    }

    // 提取命令名
    std::string command;
    size_t spacePos = line.find(' ');
    size_t parenPos = line.find('(');

    if (parenPos != std::string::npos && (spacePos == std::string::npos || parenPos < spacePos)) {
        command = line.substr(0, parenPos);
    }
    else if (spacePos != std::string::npos) {
        command = line.substr(0, spacePos);
    }
    else {
        command = line;
    }

    // 转换为小写
    std::transform(command.begin(), command.end(), command.begin(), ::tolower);

    // 匹配命令类型
    if (command == "aobscanmodule") return CommandType::AOBSCANMODULE;
    if (command == "alloc") return CommandType::ALLOC;
    if (command == "label") return CommandType::LABEL;
    if (command == "registersymbol") return CommandType::REGISTERSYMBOL;
    if (command == "unregistersymbol") return CommandType::UNREGISTERSYMBOL;
    if (command == "dealloc") return CommandType::DEALLOC;
    if (command == "db") return CommandType::DB;

    // 默认为汇编指令
    return CommandType::ASSEMBLY;
}